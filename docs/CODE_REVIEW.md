# Code Review: Yacht Paper Simulator

**Ревьюер:** Senior Flutter/Flame  
**Фокус:** Архитектура Flame, физика, производительность, чистота кода, тестируемость.

---

## 1. Критичные баги

### 1.1 Двойное обновление камеры (yacht_game.dart)

В `update(double dt)` вызывается `_updateSmartCamera(dt)`, после чего при `dock != null` выполняется второй блок, который **перезаписывает** зум и позицию камеры другими формулами:

```dart
_updateSmartCamera(dt);  // выставляет zoom и position

if (dock != null) {
  double distanceToDock = yacht.position.y.abs();  // некорректно, если dock не в y=0
  double targetZoom = CameraMath.targetZoomFromDistanceToDock(distanceToDock);
  camera.viewfinder.zoom += ...   // перезапись результата _updateSmartCamera
  camera.viewfinder.anchor = Anchor.topCenter;
  camera.viewfinder.position = Vector2(yacht.position.x, 0);  // Y=0 вместо targetY
}
```

**Итог:** Логика "умной" камеры из `_updateSmartCamera` фактически не используется; камера ведёт себя по второму блоку (другая формула и `position.y = 0`). При причале не в начале координат расчёт дистанции неверен.

**Рекомендация:** Удалить блок `if (dock != null) { ... }` в `update()` и оставить только `_updateSmartCamera(dt)` при наличии причала. Либо явно разделить сценарии (один режим камеры — один источник истины).

### 1.2 Потенциальный NPE в _checkMooringConditions (yacht_player.dart)

```dart
void _checkMooringConditions() {
  if (game.dock!.bollardXPositions.isEmpty) return;
  // ...
  canMoerBow = dBow! < threshold && ...  // dBow может быть null при пустом bollards
  canMoerStern = dStern! < threshold && ...  // dStern аналогично
}
```

`bollards` строится из `game.dock?.bollardXPositions.map(...).toList()`. Если `bollardXPositions` пустой, мы уже вышли по `isEmpty`. Но если список не пустой, а `reduce(math.min)` на одном элементе может вести себя по-разному в разных версиях Dart — стоит явно обработать случай пустого списка после `map`. Сейчас при одном тумбе `reduce` даёт один элемент, при нуле — исключение. После `isEmpty` остаётся минимум один элемент, так что критично только аккуратность: не полагаться на `!` без проверки длины списка или использовать `bollards!.length` перед `reduce`.

**Рекомендация:** Явная проверка `bollards == null || bollards!.isEmpty` после построения списка и ранний return; тогда `dBow`/`dStern` не будут использоваться в неопределённом состоянии.

### 1.3 Хардкод сообщений о краше (yacht_player.dart)

Строки вида `_triggerCrash("КРИТИЧЕСКАЯ ОШИБКА: Столкновение носом!")` и `"АВАРИЙНЫЙ РАПОРТ"` не проходят через локализацию. В UI они отображаются как есть; при включённой мультиязычности лучше использовать `game.l10n` или ключи из `AppLocalizations` (если добавить ключи для причин Game Over).

---

## 2. Архитектурные замечания

### 2.1 Разделение YachtGame / YachtPlayer / YachtPhysics

- **YachtPhysics** — статические чистые функции, без состояния, без зависимости от Flame. Это хорошо для тестов и переносимости.
- **YachtPlayer** — компонент с физикой (скорость, руль, коллизии), интеграция через `YachtPhysics` и `game.*`. Игрок знает про `game.dock`, `game.activeWindSpeed` и т.д., что создаёт связность с игрой; для одной яхты это приемлемо.
- **YachtMasterGame** — оркестрация мира, камеры, ввода, победы/проигрыша. Дублирование обновления камеры (см. баг выше) размывает ответственность: камера должна обновляться в одном месте.

**Рекомендация:** Чётко зафиксировать: "камера при наличии причала = только _updateSmartCamera"; ввод и победа/проигрыш остаются в Game.

### 2.2 onLoad / update / render

- **onLoad:** Загрузка спрайта и создание хитбокса в YachtPlayer — нормально. В Game — построение мира и условный `startLevel` из `_pendingLevel` — логично.
- **update:** В YachtPlayer сосредоточена вся физика (течение, газ, руль, силы, субстеппинг, канаты). Объём большой, но один компонент — один корабль; при добавлении типов судов можно вынести "движок" в отдельный класс (например, `YachtMovementController`), вызываемый из `update`.
- **render:** В `YachtPlayer.render` только отрисовка спрайта, тени, руля и канатов — без тяжёлых вычислений. Хорошо. В `DashboardBase.render` — несколько `_drawIsland` и линии; тоже лёгкая графика.

Тяжёлых вычислений в `render` не обнаружено.

### 2.3 Mixins

- `HasKeyboardHandlerComponents` — на Game, обработка клавиш в `onKeyEvent` и в `_handleInput` через `HardwareKeyboard.instance.logicalKeysPressed`. Корректно.
- `HasCollisionDetection` — на Game; у яхты и причала/других яхт — коллайдеры, колбэки в YachtPlayer. Ок.
- `CollisionCallbacks` (onCollisionStart, onCollision) — используются по назначению.
- `HasGameReference<YachtMasterGame>` — даёт доступ к игре из компонента; используется для dock, ветра, статуса, overlay. Альтернатива — передавать только нужные данные (например, провайдер "окружения"), но для текущего масштаба допустимо.

---

## 3. Физика и производительность

### 3.1 Delta time (dt)

- **YachtPlayer:** Все перемещения и интеграция используют `dt`: течение `* dt`, газ/руль `* dt`, силы `* dt`, угловая скорость `* dt`, субстеппинг `stepDt = dt / steps`. Скорость в м/с, перевод в пиксели через `Constants.pixelRatio` — корректно.
- **YachtPhysics:** Силы и моменты возвращаются в Н и Н·м; умножение на `dt` выполняется в вызывающем коде. В `mooringTension` внутри есть `* dt * 160` — зависимость от шага по времени учтена.
- **Камера:** Лерп зума `* dt * 2.0` — frame-rate independent.

Физика от FPS отвязана корректно.

### 3.2 Коллизии и Position Correction

- При контакте с Dock: откат позиции `position -= velocity * (_lastDt * Constants.pixelRatio)` и вызов `YachtPhysics.stop(...)` — уменьшают проникновение и останавливают движение.
- Дополнительно в `_handleSoftCollision`: нормаль от препятствия к игроку, глубина проникновения (приближение по "радиусам"), выталкивание `position += normal * depth` и отражение скорости. Это улучшает ощущение "твёрдого" причала.
- Обнуление боковой составляющей скорости в `onCollision` при контакте с Dock/MooredYacht снижает вдавливание.

Риск прохода сквозь текстуру причала снижен; при очень высокой скорости или большом dt субстеппинг (stepSize 1 px, maxSteps 25) частично страхует.

### 3.3 Утечки памяти и создание объектов

- **ParticleSystemComponent** в `_createSplash`: при каждом мягком столкновении в мир добавляется новый компонент с 10 частицами и lifespan 0.6 с. В Flame такие системы обычно удаляются по окончании жизни. Стоит убедиться, что используется API с автоудалением (например, `removeOnFinish: true` или аналог в вашей версии Flame), иначе при частых касаниях число компонентов будет расти.
- В `update` не создаются лишние объекты: векторы переиспользуются (например, `forwardDir`), константы вынесены. В циклах субстеппинга создаётся только необходимое.

**Рекомендация:** Проверить документацию Flame по `ParticleSystemComponent`: включать автоудаление после окончания жизни или вручную вызывать `removeFromParent()` по таймеру/событию.

---

## 4. UI и интеграция с Flutter

### 4.1 Оверлеи

- Победа и Game Over показываются через `overlays.add('Victory')` / `'GameOver'`, контент строится в `overlayBuilderMap` в `GameView`. Один раз при показе — без лишних пересозданий.
- MooringMenu показывается/скрывается через `showMooringButtons` / `hideMooringButtons` с защитой от мерцания (проверка `bowButtonActive == bow && sternButtonActive == stern`). Реализация адекватна.

### 4.2 Связь игра ↔ UI

- Состояние кнопок швартовки и оверлеев хранится в Game (`bowButtonActive`, `sternButtonActive`), обновляется из YachtPlayer в `_checkMooringConditions` через `game.showMooringButtons`/`hideMooringButtons`. Прямая связь компонент → игра — приемлемо для данного проекта.
- Локализации: в Game есть `AppLocalizations? l10n`, выставляемый из `GameView.build`. Для оверлеев используется `AppLocalizations.of(context)!`. Состояние языка через Provider (LocaleNotifier) — корректно.

Расширение до ValueNotifier/Stream для статусных сообщений (например, для логов или туториалов) можно делать по необходимости; для текущего набора оверлеев не обязательно.

---

## 5. Чистота кода и расширяемость

### 5.1 Магические числа

Рекомендуется вынести в `constants.dart` или в конфиг уровня/камеры:

| Где | Значение | Предложение |
|-----|----------|-------------|
| yacht_game.dart | `140.0` (высота причала) | `Constants.dockHeightPixels` или в LevelConfig |
| yacht_game.dart | `0.8`, `1.2` (скорость изменения throttle/rudder от клавиш) | `Constants.inputThrottleRate`, `Constants.inputRudderRate` |
| yacht_game.dart | `2.0` (скорость лерпа камеры) | `CameraMath.zoomLerpSpeed` |
| yacht_game.dart | `0.2 * Constants.pixelRatio` (порог "остановки" для победы) | `Constants.victorySpeedThresholdPixels` |
| yacht_game.dart | `10000`, `10000` (playArea), `-4000`, `-3000` (фон стола) | Константы мира, например `WorldConstants.playAreaSize`, `tableOffset` |
| yacht_player.dart | `0.05`, `0.005` (пороги обнуления скорости/угловой) | В Constants как `velocityZeroThreshold`, `angularZeroThreshold` |
| yacht_player.dart | `1.2` (throttleChangeSpeed) | `Constants.throttleChangeSpeed` |
| yacht_player.dart | `0.3` (сектор носа size.x * 0.3) | `Constants.noseSectorFactor` |
| yacht_player.dart | `3.5 * Constants.pixelRatio` (порог дистанции до тумбы) | Уже близко к константам; имя типа `mooringBollardProximityPixels` |
| camera_math.dart | `0.85`, `0.8`, `0.12`, `0.5` и т.д. | Уже в CameraMath; при желании можно сгруппировать в один конфиг-объект |

Часть уже в Constants; остальное вынести для единообразия и балансировки без поиска по коду.

### 5.2 Локализация и новые уровни/лодки

- Локализация подключена (l10n, arb, AppLocalizations). Сообщения о краше и статусы вроде "Bow line secured" / "Level Restarted" пока хардкод — их стоит перевести в ключи l10n и при отображении брать из `game.l10n` или context.
- Уровни задаются через `LevelConfig` и `GameLevels.allLevels`; типы окружения — enum. Добавление нового уровня = новый конфиг; нового типа лодки — новый компонент (по аналогии с MooredYacht) и при необходимости общий интерфейс "судно" для коллизий/физики.

### 5.3 Ассеты

- Спрайты загружаются через `game.loadSprite('yacht_paper.png')` и т.п. Flame кэширует загрузки по пути; повторных загрузок при каждом onLoad одного и того же пути не происходит.
- В `startLevel` вызывается `world.removeAll(world.children)`; компоненты (включая те, что держат ссылки на спрайты) удаляются. Кэш изображений остаётся в движке — это нормально. Явной выгрузки ассетов не требуется, если не планируется смена набора уровней с разными наборами картинок.

---

## 6. Тестируемость

### 6.1 Покрытие

- **yacht_engine_test.dart:** Покрыты равновесная скорость, затухание, боковой дрейф, руль, prop walk, integrationSteps, mooringTension, windForce, коллизии (resolveCollisionOutcome), MarinaLayout, CameraMath. Критичные формулы физики и константы проверены.
- **yacht_component_test.dart:** Жизненный цикл YachtPlayer, коллизии (нос/борт, мягкое касание, выталкивание, отражение скорости), швартовка (показ/скрытие кнопок), ввод. Используется TestYachtGame и моки.

Не покрыты напрямую:

- Полный цикл камеры (zoom/position) в зависимости от позиции яхты и причала — можно добавить unit для `CameraMath` и отдельный тест, что при заданных `yacht.position` и `dock.position` вызывается нужная ветка и нет двойного переопределения.
- Логика победы (два каната + скорость ниже порога) — можно вызвать `_checkVictoryCondition` в мок-игре с подготовленным состоянием яхты и проверить `overlays.contains('Victory')` и `pauseEngine`.
- Субстеппинг: что при большом `velocity * dt` число шагов растёт и позиция не "перелетает" за один кадр — частично покрыто через `integrationSteps`; интеграцию в YachtPlayer при желании можно проверить тестом с фиксированным dt и проверкой итоговой позиции.

### 6.2 Рекомендации по тестам

- Добавить тест на `_updateSmartCamera`: при заданных `dock.position`, `yacht.position` проверить, что `camera.viewfinder.zoom` и `position` лежат в ожидаемых границах и что второй блок в `update` не затирает результат (после исправления бага с камерой).
- Добавить тест победы: установить `yacht.bowMooredTo`, `yacht.sternMooredTo`, `yacht.velocity = 0`, вызвать `_checkVictoryCondition`, проверить, что оверлей добавлен и движок на паузе.
- Сохранить тесты коллизий и физики при рефакторинге констант (подставить константы в ожидания или использовать те же значения из Constants).

---

## 7. Performance-советы

- **Субстеппинг уже есть** (stepSize 1, maxSteps 25) — хорошо для уменьшения туннелирования без избыточного числа шагов.
- **Коллизии:** Flame использует внутренний broad/narrow phase; количество активных коллайдеров небольшое (яхта, причал, несколько MooredYacht). Дополнительная оптимизация не критична.
- **Рендер:** Нет тяжёлой логики в `render`; тень через `MaskFilter.blur` — фиксированная стоимость. При падении FPS в первую очередь смотреть на количество draw call’ов и сложные эффекты (если добавятся).
- **Частицы:** Ограничить частоту вызова `_createSplash` (например, не чаще раза в 0.3–0.5 с на один контакт) или лимит одновременных систем (например, не более 2–3), чтобы при серии касаний не создавать десятки компонентов.

---

## 8. Best Practices (Flutter / Flame)

- Использовать `const` конструкторы и константы там, где значения не меняются (уже частично есть; расширить на виджеты и конфиги).
- Убрать или заменить `print('DEBUG: ...')` в прод-коде на `debugPrint` или логирование через отдельный логгер (в т.ч. в TestLogger).
- Заменить устаревшие API (например, `activeColor` у Switch, `withOpacity` на `withValues` где рекомендует анализатор) в рамках планового рефакторинга.
- Имена файлов: привести к `snake_case` (например, `gameOverBuilder.dart` → `game_over_builder.dart`, `MooredYacht.dart` → `moored_yacht.dart`) для соответствия Dart style guide.
- Документация: краткие комментарии к публичным методам Game и к ключевым методам YachtPlayer/YachtPhysics уже помогают; при добавлении новых систем (например, волны, AI-лодки) описать их в том же стиле.

---

## Краткий чеклист

| Категория | Оценка | Комментарий |
|-----------|--------|-------------|
| Разделение Game/Player/Physics | Хорошо | Физика вынесена, дублирование камеры — баг |
| Использование dt | Хорошо | Везде учтён |
| Коллизии и Position Correction | Хорошо | Откат + нормаль + глубина + обнуление боковой скорости |
| Оверлеи и состояние UI | Хорошо | Без лишних перестроений |
| Магические числа | Средне | Часть в Constants, остальное вынести |
| Локализация | Средне | Есть l10n; сообщения краша/статуса — хардкод |
| Тесты | Хорошо | Физика и коллизии покрыты; камера и победа — доп. тесты |
| Производительность | Хорошо | Субстеппинг, лёгкий render; контроль частиц желателен |

Исправление двойного обновления камеры и вынос оставшихся магических чисел в константы дадут наибольший выигрыш по ясности и предсказуемости поведения.
